DEFINITION MODULE MOSCtrl;

(*
 * Internes Modul!
 *)

FROM SYSTEM IMPORT ADDRESS;
FROM GEMDOS IMPORT PtrBP;
FROM MOSGlobals IMPORT MemArea;
FROM PrgCtrl IMPORT PState;

TYPE
     EnvlpProc = PROCEDURE (    (* opening: *) BOOLEAN,
                                (* inChild: *) BOOLEAN,
                            VAR (* exitCode:*) INTEGER );

(*
 * Zeigt auf die TOS-Variable, die den aktuellen Prozess bezeichnet.
 *)
VAR ProcessID: POINTER TO PtrBP;

(*
 * Globales Modullevel.
 * Ist Eins fuer unterstes Level;
 * Null, wenn eigener Prozess nicht mehr aktiv (z.B. bei residenten Prg.).
 *)
VAR ModLevel: CARDINAL;

(*
 * TRUE, wenn Basismodule resident sind.
 * Bleibt auch erhalten, wenn Basisprozess beendet wird und Prg
 * resident bleibt.
 *)
VAR BaseResident: BOOLEAN;

(*
 * Zeigt an, ob BaseProcess ein ACC ist
 *)
VAR BaseIsAccessory: BOOLEAN;

(*
 * Erst gueltig, wenn processState = 3 (term)
 *)
VAR ExitCode: INTEGER;

(*
 * Vom Linker uebergeben: 0 = keine Reals, 1 = Soft, 2 = ST-FPU, 3 = TT-FPU
 *)
VAR RealMode: CARDINAL;

(*
 * 0: none, 1: external, 2: internal
 *)
VAR UsedFPU: CARDINAL;

TYPE TermList  = POINTER TO TermEntry;
     TermProc = PROCEDURE;
     TermEntry = RECORD
                   call: TermProc;
                   wsp : MemArea;
                   next: TermList
                 END;

     EnvList  = POINTER TO EnvEntry;
     EnvEntry = RECORD
                  call: EnvlpProc; (* PROCEDURE(start,child):BOOLEAN) *)
                  wsp: MemArea;
                  level: INTEGER;
                  prev, next: EnvList
                END;

     RemovalList  = POINTER TO RemovalEntry;
     RemovalProc = PROCEDURE;
     RemovalEntry = RECORD
                      next: RemovalList;
                      prev: RemovalList;
                      call: RemovalProc;
                      wsp: MemArea;
                    END;

VAR EnvRoot: EnvEntry;
VAR RemovalRoot: RemovalEntry;


TYPE PtrPDB = POINTER TO PDB;
     PDB = RECORD
             layout       : CARDINAL;
             basePageAddr : PtrBP;
             modLst       : POINTER TO ARRAY [1..65535] OF RECORD
                              head0: ADDRESS;
                              var0: ADDRESS;
                              varlen0: LONGCARD;
                              flags: BITSET;
                            END;
             modNo        : CARDINAL;
             processState : PState;
             bottomOfStack: ADDRESS;
             topOfStack   : ADDRESS;
             termState    : PState;
             resident     : BOOLEAN;
             flags        : CARDINAL; (* vom Linker: 0,1: RealFormat; 2: 68020-Code *)
             termProcs    : TermList;
             prev         : PtrPDB;
             initialSSP   : ADDRESS;
             prevTermHdlr : ADDRESS;
           END;

(*
 * Liefert NIL in pdb, wenn gerade kein MOS-Prozess aktiv und ModLevel > 0.
 * Wenn ein Prg also resident ist, bekommt es, wenn ModLevel = 0, zumindest
 * seinen PDB, dessen Daten teilweise noch gueltig sind (Stack-Ptr, resident,
 * modLst, usw). Wenn Prg ein ACC ist und ModLevel=1, wird PDB geliefert.
 * 'process' enthaelt immer akt. laufenden TOS-Prozess (akt.Basepage)
 *)
PROCEDURE GetPDB ( VAR pdb: PtrPDB; VAR process: ADDRESS );

(*
 * Es muss die Adresse eines bereits angelegten
 * und initialisierten PDB uebergeben werden.
 *)
PROCEDURE PushPDB ( pdb: PtrPDB; process: PtrBP );

PROCEDURE PopPDB;

(*
 * Muss unbedingt immer aufgerufen werden, weil hierin nicht nur
 * der Prozess-Status gesetzt, sondern auch abhaengig davon andere
 * Operationen durchgefuehrt werden! Also keinesfalls PDB.processState
 * direkt setzen!
 *)
PROCEDURE SetProcessState ( state: PState );

PROCEDURE CallSub ( subRoutine: PROC; VAR wsp: MemArea );

(*
 * Entfernt u.A. den Termination-Handler
 *)
PROCEDURE CallRemoveProcs;

(*
 * Ersatz fuer GEMDOS-Pterm(). Fuehrt Abmeldefunktionen vorher aus.
 *)
PROCEDURE Pterm (exitCod: INTEGER);

(*
 * Folg. zwei Vars bezeichnen letzten aktiven MOS-Prozess
 *)
VAR ActPDB : PtrPDB;            (* Bleibt nach unterstem Prozessende erhalten *)
VAR ActMOSProcess: PtrBP;       (* Ist NIL unter unterstem Prozesslevel *)

VAR BaseProcess: PtrBP;         (* Bei ACCs hier Base Page des ACC *)

END MOSCtrl.
