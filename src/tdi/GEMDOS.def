DEFINITION MODULE GEMDOS;

(* ---------------------------------------------------------------------

        Modula-2 interface to GEM Disk Operating System

   For full documentation on the GEMDOS interface please see the GEMDOS
   manual.

   --------------------------------------------------------------------- *)

(* GEM is a registered trademark of Digital Research Inc. *)


(* ---------------------------------------------------------------------- *)
(* (c) Copyright 1986, 1987  Modula-2 Software Ltd.  All Rights Reserved. *)
(* ---------------------------------------------------------------------- *)
(* (c) Copyright 1986, 1987  TDI Software, Inc.      All Rights Reserved. *)
(* ---------------------------------------------------------------------- *)


FROM SYSTEM IMPORT ADDRESS;

CONST
  (* BIOS error codes *)
  EOK           =   0;
  Error         =  -1;
  EDrvNR        =  -2;         (* Drive not ready *)
  EUnCmd        =  -3;         (* Unknown command *)
  ECRC          =  -4;         (* CRC error *)
  EBadRq        =  -5;         (* Bad request *)
  ESeek         =  -6;         (* Seek error *)
  EMedia        =  -7;         (* Unknown media *)
  ESecNF        =  -8;         (* Sector not found *)
  EPaper        =  -9;         (* No paper *)
  EWritF        = -10;         (* Write fault *)
  EReadF        = -11;         (* Read fault *)
  EGenrl        = -12;         (* General error *)
  EWrPro        = -13;         (* Write protect *)
  EChng         = -14;         (* Media change *)
  EUnDev        = -15;         (* Unknown device *)
  EBadSF        = -16;         (* Bad sectors on format *)
  EOther        = -17;         (* Insert other disk *)

  (* BDOS Error codes *)
  EInvFN        = -32;         (* Invalid function number *)
  EFilNF        = -33;         (* File not found *)
  EPthNF        = -34;         (* Path not found *)
  ENHndl        = -35;         (* No handles left *)
  EAccDn        = -36;         (* Access denied *)
  EIHndl        = -37;         (* Invalid handle *)
  ENSMem        = -39;         (* Insufficient memory *)
  EIMBA         = -40;         (* Invalid memory block address *)
  EDrive        = -46;         (* Invaild drive specified *)
  ENMFil        = -49;         (* No more files *)

  (* Other errors *)
  ERange        = -64;         (* Range error *)
  EIntrn        = -65;         (* Internal error *)
  EPLFmt        = -66;         (* Invalid program load format *)
  EGSBF         = -67;         (* Setblock failure due to growth restr *)

TYPE
  IOMode = (read, write)

  SeekMode = (beginning, relative, end)

  ExecMode = (loadExecute, resrvd1, resrvd2, load)

  SetOrGet = (set, get)

  DiskInfoBuffer = RECORD 
                     freeSpace   : LONGCARD; (* in clusters *)
                     clusters    : LONGCARD; (* num on disk *)
                     sectorSize  : LONGCARD; (* in bytes *)
                     clusterSize : LONGCARD; (* sectors per cluster *)
                   END;

(* 1 *) PROCEDURE OldTerm (); 
(* Terminate process (old version) *)

(* 2 *) PROCEDURE ConIn(VAR Ch: CHAR) 
(* Read character from standard input *)

(* 3 *) PROCEDURE ConScanIn(VAR Ch, Scan: CHAR); 
(* Read character and scan code from standard input *)

(* 4 *) PROCEDURE ConOut(Ch: CHAR); 
(* Write character to standard output *)

(* 5 *) PROCEDURE AuxIn(VAR Ch: CHAR); 
(* Read character from auxiliary port *)

(* 6 *) PROCEDURE AuxOut(Ch: CHAR); 
(* Write character to auxiliary port *)

(* 7 *) PROCEDURE PrnOut(Ch: CHAR); 
(* Write character to printer port *)

(* 8 *) PROCEDURE RawIO(VAR Ch: CHAR; Mode: IOMode); 
(* Raw IO to standard input/output device *)

(* 9 *) PROCEDURE RawIn(VAR Ch: CHAR); 
(* Raw input from standard input *)

(* 10 *) PROCEDURE RawScanIn(VAR Ch, Scan: CHAR); 
(* Raw inpput of character and scan code from standard input *)

(* 11 *) PROCEDURE NecIn(VAR Ch: CHAR); 
(* Read character from standard input with no echo *)

(* 12 *) PROCEDURE ConWS(VAR String: ARRAY OF CHAR); 
(* Write null terminated string to standard output device *)

(* 13 *) PROCEDURE ConRS(VAR String: ARRAY OF CHAR); 
(* Read edited string from standard input device *)

(* 14 *) PROCEDURE ConIS (): BOOLEAN; 
(* Return status of standard input *)

(* 15 *) PROCEDURE SetDrv(Drive: CARDINAL; VAR DriveMap: LONGCARD); 
(* Set default drive *)

(* 16 *) PROCEDURE ConOS (): BOOLEAN; 
(* Return output status of standard output *)

(* 17 *) PROCEDURE PrnOS (): BOOLEAN; 
(* Return output status of standard printer *)

(* 18 *) PROCEDURE AuxIS (): BOOLEAN; 
(* Return status of standard auxiliary *)

(* 19 *) PROCEDURE AuxOS (): BOOLEAN; 
(* Return output status of standard auxiliary *)

(* 20 *) PROCEDURE GetDrv(VAR Drive: CARDINAL); 
(* Get default drive *)

(* 21 *) PROCEDURE SetDTA(Address: ADDRESS); 
(* Set disk transfer address *)

(* 22 *) PROCEDURE GetDate(VAR Date: CARDINAL); 
(* Get Date *)

(* 23 *) PROCEDURE SetDate(Date: CARDINAL); 
(* Set Date *)

(* 24 *) PROCEDURE GetTime(VAR Time: CARDINAL); 
(* Get Date *)

(* 25 *) PROCEDURE SetTime(Time: CARDINAL); 
(* Set Date *)

(* 26 *) PROCEDURE GetDTA(VAR Addr: ADDRESS); 
(* Get disk transfer address *)

(* 27 *) PROCEDURE Version(VAR Ver: CARDINAL); 
(* Get version number *)

(* 28 *) PROCEDURE TermRes(NumBytes: LONGCARD; ExitCode: CARDINAL); 
(* Terminate and stay resident *)

(* 29 *) PROCEDURE DFree (VAR InfoBuffer: DiskInfoBuffer; Drive: CARDINAL); 
(* Get drive free space *)

(* 30 *) PROCEDURE DirCreate(VAR Path: ARRAY OF CHAR ): BOOLEAN; 
(* Create a subdirectory *)

(* 31 *) PROCEDURE DirDelete(VAR Path: ARRAY OF CHAR ): BOOLEAN; 
(* Delete a subdirectory *)

(* 32 *) PROCEDURE SetPath(VAR Path: ARRAY OF CHAR ): BOOLEAN; 
(* Set current directory *)

(* 33 *) PROCEDURE Create(VAR Name: ARRAY OF CHAR; Attr: CARDINAL; 
                   VAR Handle: INTEGER );
(* Create a file *)

(* 34 *) PROCEDURE Open(VAR Name: ARRAY OF CHAR; Mode: CARDINAL; 
                 VAR Handle: INTEGER);
(* Open a file *)

(* 35 *) PROCEDURE Close(Handle: INTEGER ): BOOLEAN; 
(* Close a file *)

(* 36 *) PROCEDURE Read(Handle: INTEGER; VAR Count: LONGCARD; Buffer: ADDRESS); 
(* Read file *)

(* 37 *) PROCEDURE Write(Handle: INTEGER; VAR Count: LONGCARD; Buffer: ADDRESS);(* Write file *) 

(* 38 *) PROCEDURE Delete(VAR Name: ARRAY OF CHAR ): BOOLEAN; 
(* Delete file *)

(* 39 *) PROCEDURE Seek(Offset: LONGINT; Handle: INTEGER; Mode: SeekMode; VAR Position: LONGCARD);
(* Seek file pointer *)

(* 40 *) PROCEDURE Attrib(VAR Name: ARRAY OF CHAR; Which: SetOrGet;  
                   VAR Attr: CARDINAL);
(* Get/Set file attributes *)

(* 41 *) PROCEDURE GetPath(VAR PathName: ARRAY OF CHAR; Drive: CARDINAL); 
(* Get current directory *)

(* 42 *) PROCEDURE Alloc(Bytes: LONGCARD; VAR Addr: ADDRESS); 
(* Allocate memory *)

(* 43 *) PROCEDURE Free(Addr: ADDRESS ): BOOLEAN; 
(* Free memory *)

(* 44 *) PROCEDURE Shrink(Addr: ADDRESS; NewSize: LONGCARD ): BOOLEAN; 
(* Shrink size of allocated memory *)

(* 45 *) PROCEDURE Exec(Mode: ExecMode; VAR Name: ARRAY OF CHAR;  
                 VAR Tail: ARRAY OF CHAR; VAR EnvStr: ARRAY OF CHAR;
                 VAR Result: INTEGER);
(* Load or execute a process *)

(* 46 *) PROCEDURE Term(Code: INTEGER ): BOOLEAN; 
(* Terminate a process *)

(* 47 *) PROCEDURE SFirst(VAR Name: ARRAY OF CHAR; Attr: CARDINAL; 
                   VAR Result: INTEGER);
(* Search for first file *)

(* 48 *) PROCEDURE SNext(VAR Result: INTEGER); 
(* Search for next file *)

(* 49 *) PROCEDURE Rename(VAR CurrentName, NewName: ARRAY OF CHAR); 
(* Rename a file *)

(* 50 *) PROCEDURE DaTime(Handle: INTEGER; Buffer: ADDRESS; Which: SetOrGet); 
(* Get/Set file date and time stamp *)

(* 51 *) PROCEDURE Super(VAR stack: ADDRESS); 
(* enter supervisor mode if stack = 0, otherwise come out of
   supervisor mode with the given stack. *)

END GEMDOS.
