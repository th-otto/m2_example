(****************************************
*                                       *
*     MODULA-2 Multi-Pass Compiler      *
*     ****************************      *
*                                       *
*     Implementation for Lilith         *
*                                       *
*                                       *
*     MCP1Ident:                        *
*                                       *
*     Identifier handling in Pass 1     *
*                                       *
*     Version C18 of 17.12.81           *
*                                       *
*     Institut fuer Informatik          *
*     ETH-Zuerich                       *
*     CH-8092 Zuerich                   *
*                                       *
****************************************)

IMPLEMENTATION MODULE MCP1Ident;   (* LG *)

(* $T-,R- *)

FROM Storage IMPORT ALLOCATE, DEALLOCATE;
FROM MCBase IMPORT
  noprio,
  Idptr, Stptr, Idclass, Structform,
  Varkind, Kindvar,
  Stpures, Stfuncs, Spellix, Symbol,
  root, boolptr, charptr, intptr, cardptr,
  intcarptr, realptr, longrealptr, byteptr, wordptr, longwordptr, bitsetptr, longbitsetptr, anyrealptr,
  strptrs, substptr, sgnintsptr, longintptr, longcardptr,
  addrptr, procptr, processptr, niltypeptr, mainmodp, sysmodp;
FROM MCP1IO IMPORT HashIdent, EnterResWord, String14, spix;

CONST oneword = 1; (* space for allocation *)
      doubleword = 2 * oneword;
      procmarkspace = 4 * oneword; (* space used for procedure mark *)
      addrsize = 4;

VAR curlistp : Idptr;


PROCEDURE EnterName(VAR p: Idptr; VAR str: String14);
  (* initialisation and name entry *)
  VAR p1, p2: Idptr;
BEGIN
  HashIdent(str);
  WITH p^ DO (* initialise *)
    name := spix; (* generated by HashIdent *)
    link := NIL;
    idtyp := NIL;
    globmodp := mainmodp;
  END;
  p1 := curlistp;
  WHILE (p1<>NIL)AND(spix>p1^.name) DO
    p2 := p1;
    p1 := p1^.link;
  END;
  p^.link := p1;
  IF p1=curlistp THEN curlistp := p ELSE p2^.link := p END
END EnterName;


PROCEDURE EnterMod(sysmod: BOOLEAN);
  VAR p : Idptr;
      str : String14;
BEGIN
  NEW(p,mods,FALSE,mods,FALSE);
  mainmodp := p;
  IF sysmod THEN
    str := "SYSTEM";
    HashIdent(str)
  ELSE
    root := p;
    str := "S.M."; (* standard module *)
    HashIdent(str);
  END;
  WITH p^ DO
    name := spix;
    klass := mods;
    globmodp := mainmodp;
    link := NIL;
    idtyp := NIL;
    expp := NIL;
    impp := NIL;
    locp := NIL;
    msp := NIL;
    isstandard := FALSE;
    priolev := noprio;
    externalaccess := FALSE;
    qualexp := sysmod; (* if TRUE then module SYSTEM *)
    globalmodule := FALSE;
  END;
  curlistp := NIL;
END EnterMod;


PROCEDURE EnterProc(str: String14; pn: Stpures; tp: Stptr);
  VAR p: Idptr;
BEGIN
  NEW(p, pures, TRUE);
  EnterName(p,str);
  WITH p^ DO
    klass := pures;
    idtyp := tp; (* must be <> NIL for substituted procedures *)
    isstandard := TRUE;
    pname := pn;
  END;
END EnterProc;


PROCEDURE EnterFunc(str: String14; fn: Stfuncs);
  VAR p: Idptr;
BEGIN
  NEW(p, funcs, TRUE);
  EnterName(p,str);
  WITH p^ DO
    klass := funcs;
    isstandard := TRUE;
    fname := fn;
  END;
END EnterFunc;

PROCEDURE BaseType(sf: Structform): Stptr;
  VAR sp : Stptr;
BEGIN
  NEW(sp,bools);
  WITH sp^ DO
    CASE sf OF
      bools,chars,ints,cards,words: size := oneword;
     |reals: size := doubleword;
    END;
    stidp := NIL; inlist := TRUE;
    form := sf;
  END;
  RETURN sp
END BaseType;


PROCEDURE SubrStruct(mi,ma: CARDINAL): Stptr;
  VAR sp : Stptr;
BEGIN
  NEW(sp,subranges);
  WITH sp^ DO
    size := oneword; form := subranges;
    stidp := NIL; inlist := TRUE;
    scalp := cardptr;
    min := mi; max := ma;
  END;
  RETURN sp
END SubrStruct;


PROCEDURE PointerStruct(tp : Stptr): Stptr;
  VAR sp : Stptr;
BEGIN
  NEW(sp,pointers);
  WITH sp^ DO
    size := addrsize; form := pointers;
    stidp := NIL; inlist := TRUE;
    elemp := tp;
  END;
  RETURN sp
END PointerStruct;


PROCEDURE SetStruct(bits: CARDINAL): Stptr;
  VAR sp : Stptr;
BEGIN
  NEW(sp,sets);
  WITH sp^ DO
    IF bits > 16 THEN
      size := oneword * 2;
    ELSE
      size := oneword;
    END;
    form := sets;
    stidp := NIL; inlist := TRUE;
    basep := SubrStruct(0,bits-1);
  END;
  RETURN sp
END SetStruct;


PROCEDURE ProcedureStruct(fp: Idptr): Stptr;
  VAR sp : Stptr;
BEGIN
  NEW(sp,proctypes,pures);
  WITH sp^ DO
    size := oneword; form := proctypes; rkind := pures;
    stidp := NIL; inlist := TRUE;
    fstparam := fp;
  END;
  RETURN sp
END ProcedureStruct;


PROCEDURE EnterVar(str: String14; tp: Stptr; ad: CARDINAL);
  VAR p : Idptr;
BEGIN
  NEW(p,vars);
  EnterName(p,str);
  WITH p^ DO
    idtyp := tp;
    klass := vars;
    indaccess := FALSE;
    vlevel := 0;
    vaddr := ad;
    state := absolute;
    vkind := noparam;
    vlink := NIL;
  END;
END EnterVar;


PROCEDURE EnterParam(tp: Stptr; ad: CARDINAL; vk: Varkind; VAR np: Idptr);
  VAR p : Idptr;
BEGIN
  NEW(p,vars);
  WITH p^ DO
    name := 0; idtyp := tp;
    globmodp := mainmodp;
    klass := vars;
    indaccess := vk = varparam;
    vlevel := 1;
    vaddr := ad;
    state := local;
    vkind := vk;
    vlink := np
  END;
  np := p
END EnterParam;


PROCEDURE EnterType(str: String14; tp: Stptr);
  VAR p : Idptr;
BEGIN
  NEW(p,types);
  EnterName(p,str);
  WITH p^ DO
    klass := types;
    idtyp := tp;
  END;
  tp^.stidp := p; (* link structure with name *)
END EnterType;


PROCEDURE EnterConst(str: String14; tp: Stptr; valu: CARDINAL);
  VAR p : Idptr;
BEGIN
  NEW(p,consts);
  EnterName(p,str);
  WITH p^ DO
    idtyp := tp;
    klass := consts;
    cvalue.value := valu;
  END;
END EnterConst;


PROCEDURE InitResWords;
BEGIN
  EnterResWord('AND',andsy);            (* reserved words *)
  EnterResWord('DIV',divsy);
  EnterResWord('MOD',modsy);
  EnterResWord('NOT',notsy);
  EnterResWord('OR',orsy);
  EnterResWord('IN',insy);
  EnterResWord('CONST',constsy);
  EnterResWord('TYPE',typesy);
  EnterResWord('VAR',varsy);
  EnterResWord('ARRAY',arraysy);
  EnterResWord('RECORD',recordsy);
  EnterResWord('SET',setsy);
  EnterResWord('POINTER',pointersy);
  EnterResWord('TO',tosy);
  EnterResWord('IMPORT',importsy);
  EnterResWord('EXPORT',exportsy);
  EnterResWord('FROM',fromsy);
  EnterResWord('QUALIFIED',qualifiedsy);
  EnterResWord('DEFINITION',definitionsy);
  EnterResWord('IMPLEMENTATION',implementationsy);
  EnterResWord('PROCEDURE',proceduresy);
  EnterResWord('MODULE',modulesy);
  EnterResWord('BEGIN',beginsy);
  EnterResWord('CASE',casesy);
  EnterResWord('OF',ofsy);
  EnterResWord('IF',ifsy);
  EnterResWord('THEN',thensy);
  EnterResWord('ELSIF',elsifsy);
  EnterResWord('ELSE',elsesy);
  EnterResWord('LOOP',loopsy);
  EnterResWord('EXIT',exitsy);
  EnterResWord('REPEAT',repeatsy);
  EnterResWord('UNTIL',untilsy);
  EnterResWord('WHILE',whilesy);
  EnterResWord('WITH',withsy);
  EnterResWord('INLINE',inlinesy);
  EnterResWord('DO',dosy);
  EnterResWord('FOR',forsy);
  EnterResWord('BY',bysy);
  EnterResWord('RETURN',returnsy);
  EnterResWord('END',endsy);
END InitResWords;


PROCEDURE InitStandards;
  VAR 
      parp : Idptr;
      prp : Stptr;
      ix : CARDINAL;
BEGIN
  (* standard module *)
  EnterMod(FALSE);
  boolptr := BaseType(bools);
  charptr := BaseType(chars);
  intptr := BaseType(ints);
  cardptr := BaseType(cards);
  intcarptr := BaseType(intcards);
  sgnintsptr := BaseType(sgnints);
  longintptr := BaseType(longints);
  longcardptr := BaseType(longcards);
  realptr := BaseType(reals);
  longrealptr := BaseType(longreals);
  anyrealptr := BaseType(anyreals);
  bitsetptr := SetStruct(16);
  longbitsetptr := SetStruct(32);
  niltypeptr := PointerStruct(NIL);
  procptr := ProcedureStruct(NIL); (* PROCEDURE *)

  EnterType('BOOLEAN',boolptr);
  EnterType('CHAR',charptr);
  EnterType('INTEGER',intptr);
  EnterType('CARDINAL',cardptr);
  EnterType('LONGINT',longintptr);
  EnterType('LONGCARD',longcardptr);
  EnterType('BITSET',bitsetptr);
  EnterType('LONGBITSET',longbitsetptr);
  EnterType('UNS-TYPE',intcarptr);
  EnterType('SGN-TYPE',sgnintsptr);
  EnterType('INT-CARD',intcarptr);
  EnterType('LONGINT-CARD',intcarptr);
  EnterType('NIL-TYPE',niltypeptr);
  EnterType('PROC',procptr);

  EnterConst('FALSE',boolptr,0);
  EnterConst('TRUE',boolptr,1);
  EnterConst('NIL',niltypeptr,4294967295);

  EnterProc('DEC', decp,NIL);      (* standard procedures *)
  EnterProc('EXCL', exclp,NIL);
  EnterProc('HALT', haltp,NIL);
  EnterProc('INC', incp,NIL);
  EnterProc('INCL', inclp,NIL);
  EnterProc('NEW', newp,NIL);
  EnterProc('DISPOSE', disposep,NIL);
  EnterFunc('ABS', absf);           (* standard functions *)
  EnterFunc('CAP', capf);
  EnterFunc('CHR', chrf);
  EnterFunc('HIGH', higf);
  EnterFunc('MIN', minf);
  EnterFunc('MAX', maxf);
  EnterFunc('SHORT', shortf);
  EnterFunc('LONG', longf);
  EnterFunc('ODD', oddf);
  EnterFunc('ORD', ordf);
  EnterFunc('VAL', valf);
  EnterFunc('SIZE', sizf);

  mainmodp^.expp := curlistp;

  EnterType('REAL',realptr);
  EnterType('LONGREAL',longrealptr);

  EnterFunc('FLOAT', fltf);
  EnterFunc('TRUNC', trcf);
  EnterFunc('FLOATD', lfltf);
  EnterFunc('TRUNCD', ltrcf);

  (* initialisation of string structure table *)
  FOR ix := 0 TO 20 DO strptrs[ix] := NIL END;

  (* module SYSTEM *)
  EnterMod(TRUE);
  byteptr := BaseType(bytes);
  wordptr := BaseType(words);
  longwordptr := BaseType(longwords);
  addrptr := BaseType(addrs);
  processptr := PointerStruct(addrptr);

  EnterType('BYTE',byteptr);
  EnterType('WORD',wordptr);
  EnterType('LONGWORD',longwordptr);
  EnterType('PROCESS',processptr);
  EnterType('ADDRESS',addrptr);

  (* SYSTEM procedures *)
  EnterProc('NEWPROCESS',nprp,NIL);
  EnterProc('TRANSFER',trsp,NIL);
  EnterProc('CODE',codep,NIL);
  EnterProc('IOTRANSFER',iotrsp,NIL);
  EnterProc('LISTEN',listenp,NIL);
  EnterProc('SUPERVISOR',superp,NIL);
  EnterProc('USER',userp,NIL);
  EnterProc('SETREG',setregp,NIL);
  EnterProc('PUSH',pushp,NIL);
  EnterProc('POP',popp,NIL);
  (* SYSTEM functions *)
  EnterFunc('ASH', ashf);
  EnterFunc('ADR', adrf);
  EnterFunc('REGISTER', registerf);
  EnterFunc('TSIZE', tsizef);

  EnterConst('NULL',niltypeptr,0);
  EnterConst('BITSPERBYTE',intcarptr,8);
  EnterConst('BITSPERWORD',intcarptr,16);
  EnterConst('BITSPERLONGWORD',intcarptr,32);

  mainmodp^.expp := curlistp;
  sysmodp := mainmodp;

  (* initialisation of substitution procedures *)
  curlistp := NIL;
  parp := NIL;
  EnterParam(longcardptr, procmarkspace + oneword,valparam,parp);
  EnterParam(addrptr,procmarkspace,varparam,parp);
  prp := ProcedureStruct(parp); (* PROCEDURE(VAR ADDRESS,CARDINAL) *)
  EnterProc("ALLOCATE",newp,prp); (* substitution for NEW *)
  EnterProc("DEALLOCATE",disposep,prp); (* substitution for DISPOSE *)
  substptr := curlistp;
END InitStandards;


PROCEDURE InitIdTables;
BEGIN
  InitResWords;
  InitStandards;
END InitIdTables;


END MCP1Ident.
